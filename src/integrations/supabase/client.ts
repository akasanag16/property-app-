
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://smooniqpqenxdbkceppn.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNtb29uaXFwcWVueGRia2NlcHBuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUyNjI0ODUsImV4cCI6MjA2MDgzODQ4NX0.MhwwE_baKbSuSM8yHUxgREWGwOxEHhW05RygLy3xHBw";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Define the structure for tables we need to access with proper typing
type Tables = {
  profiles: Database['public']['Tables']['profiles']['Row'];
  properties: Database['public']['Tables']['properties']['Row'];
  property_images: Database['public']['Tables']['property_images']['Row'];
  maintenance_requests: Database['public']['Tables']['maintenance_requests']['Row'];
  service_provider_property_link: Database['public']['Tables']['service_provider_property_link']['Row'];
  tenant_property_link: Database['public']['Tables']['tenant_property_link']['Row'];
  notifications: Database['public']['Tables']['notifications']['Row'];
  tenant_invitations: Database['public']['Tables']['tenant_invitations']['Row'];
  service_provider_invitations: Database['public']['Tables']['service_provider_invitations']['Row'];
}

// Type definitions for our custom RPC functions
type RPCFunctions = {
  get_tenant_properties: (args: { tenant_id: string }) => Promise<{
    data: string[];
    error: any;
  }>;
  get_property_name: (args: { property_id_param: string }) => Promise<{
    data: string;
    error: any;
  }>;
  get_service_provider_properties: (args: { provider_id: string }) => Promise<{
    data: string[];
    error: any;
  }>;
  get_service_provider_maintenance_requests: (args: { provider_id: string }) => Promise<{
    data: string[];
    error: any;
  }>;
  get_properties_for_service_provider: (args: { provider_id: string }) => Promise<{
    data: any[];
    error: any;
  }>;
  is_owner_of_property_safe: (args: { property_id: string }) => Promise<{
    data: boolean;
    error: any;
  }>;
  is_service_provider_for_property_safe: (args: { property_id: string }) => Promise<{
    data: boolean;
    error: any;
  }>;
  is_tenant_of_property_safe: (args: { property_id: string }) => Promise<{
    data: boolean;
    error: any;
  }>;
  get_property_invitations: (args: { p_property_id: string, p_type: string }) => Promise<{
    data: any[];
    error: any;
  }>;
  create_invitation: (args: { p_property_id: string, p_email: string, p_link_token: string, p_type: string }) => Promise<{
    data: string;
    error: any;
  }>;
  update_invitation_expiry: (args: { p_invitation_id: string, p_invitation_type: string }) => Promise<{
    data: null;
    error: any;
  }>;
  get_user_notifications: (args: { user_id_param: string }) => Promise<{
    data: Database['public']['Tables']['notifications']['Row'][];
    error: any;
  }>;
  mark_notification_as_read: (args: { notification_id_param: string }) => Promise<{
    data: null;
    error: any;
  }>;
  mark_all_notifications_as_read: (args: { user_id_param: string }) => Promise<{
    data: null;
    error: any;
  }>;
  create_notification: (args: { user_id_param: string, title_param: string, message_param: string, type_param: string, related_entity_id_param?: string, related_entity_type_param?: string }) => Promise<{
    data: string;
    error: any;
  }>;
  create_property: (args: { name_param: string, address_param: string, owner_id_param: string, details_param?: any }) => Promise<{
    data: string;
    error: any;
  }>;
  begin_transaction: () => Promise<{
    data: null;
    error: any;
  }>;
  commit_transaction: () => Promise<{
    data: null;
    error: any;
  }>;
  rollback_transaction: () => Promise<{
    data: null;
    error: any;
  }>;
}

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  },
  global: {
    // Add proper abort controller and prevent recursion
    fetch: (url, options) => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      return fetch(url, {
        ...options,
        signal: options?.signal || controller.signal,
        headers: {
          ...options?.headers,
          'X-Client-Info': 'lovable-app', // Custom header to help identify client
        }
      }).finally(() => clearTimeout(timeoutId));
    },
  },
});

// Create a storage bucket for property images if it doesn't exist
// We run this in a separate context to avoid RLS recursion issues
(async () => {
  try {
    // Check if the bucket exists first
    const { data: buckets, error: listError } = await supabase.storage.listBuckets();
    
    if (listError) {
      console.error('Error listing storage buckets:', listError);
      return;
    }
    
    const propertyImagesBucketExists = buckets?.some(bucket => bucket.name === 'property_images');
    
    if (!propertyImagesBucketExists) {
      // Attempt to create the bucket if it doesn't exist
      const { error: createError } = await supabase.storage.createBucket('property_images', {
        public: true,
        fileSizeLimit: 10485760, // 10MB
        allowedMimeTypes: ['image/png', 'image/jpeg', 'image/gif', 'image/webp']
      });
      
      if (createError) {
        console.error('Error creating storage bucket:', createError);
        // Don't throw error here, just log it to avoid blocking app initialization
      } else {
        console.log('Created property_images storage bucket');
      }
    }
  } catch (error) {
    console.error('Error checking/creating storage bucket:', error);
    // Don't throw error here, just log it to avoid blocking app initialization
  }
})();
